---
title: ''
output: pdf_document
---

\section{Preliminary Work and Simulations}
\label{Sec:simulations}

```{r simulatedata}
library(mvtnorm) #needed for multivariate normal
library(MCMCpack) #needed for inverse wishart
library(BayesLogit) #pollygamma sampling
library(cubature) #numerical integration
library(MASS)
library(LCMCR)
library(ellipse) #helpful for plotting ellipses
library(ggplot2)
library(GGally)
library(dplyr)

RMSE <- function(x,N){
  sqrt(mean((x-N)^2))
}

#Load simdata
simdat<-readRDS("simdata/simdata11122022.rds")
simdat=simdat[complete.cases(simdat),]
simdat$N = as.numeric(simdat$N)
simdat$n = as.numeric(simdat$n)


#remove NA
#simdat=simdat[-which(is.na(simdat$N)),]
```

In this section, we run numerous simulations covering a number of different types of situations including varying levels of list dependency, sizes of population, non-normal covariate distributions, and unobservable heterogeneity. The primary objective is to examine the results of the Bayesian Logistic Regression Capture-Recapture (BLRCR) model. Along with the BLRCR algorithm, we compare our results using four other capture-recapture algorithms. The first algorithm we use is conditional maximum likelihood logistic regression (cMLCR) which is implemented using the \texttt{VGAM} package in \texttt{R} (see subsection \ref{Sec:selectcovariates}).  Instead of using the asymptotic estimates for the standard error and assuming normality, we use a semiparametric bootstrap for the confidence intervals \citep{zwane_implementing_2003}. Second, we implement the ubiquitous hierarchical log-linear (Log Linear) modelling technique \citep{fienberg_multiple_1972} using the the \texttt{Rcapture} package in \texttt{R}. Keep in mind that this approach does not use covariates, but attempts to model list dependency directly through list interactions. Since the approach is hierarchical with $2^J$ different model constructions, all are calculated and the one with the lowest BIC is selected. Third, we use the Bayesian Non-Parametric Latent-Class Capture-Recapture (LCMCR) algorithm in \cite{manriquevallier_bayesian_2016} which is another technique that does not allow covariates but uses a Bayesian nonparametric approach to account for unobserved heterogeneity (see appendix \ref{LCMCRmodel} for a summary of this approach). The fourth technique is a simple independence model (Independent) where it is assumed there is no list or individual heterogeneity. Conveniently, when the number of latent classes is set equal to one, the LCMCR model collapses into an independence model, effectively giving a Bayesian independence sampler (Independent).

We estimate $N$ using the BLRCR model under three different specifications.  First, we consider a single multivariate normal to describe the covariate distribution ($K=1$) and no hidden heterogeneity ($H_\omega$=1).  Second, we allow for a mixture of multivariate normal distributions under the stick-breaking prior with a sufficiently large number of classes, $K=20$, but still do not allow for additional unobserved heterogeneity.  The third specification is similar to the second but now allows hidden heterogeneity with up to $H_\omega=20$ different latent intercepts. Also, the BLRCR model requires a prior mean and covariance for the coefficients, which are set to $$\boldsymbol{b}=\boldsymbol{0} \text{ and } \boldsymbol{B}=\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1
\end{bmatrix}.$$

In addition to priors on the coefficients, BLRCR and LCMCR require additional hyperparameter specifications for the mixture distributions which can be found in \autoref{table:hyperparams}.  The number of samples in each simulation for each algorithm is set to 10,000 unless otherwise stated. 


\begin{table}[H]
\centering
\begin{tabular}{||r r r||} 
\hline
& \multicolumn{2}{ c |}{Algorithm}\\
\hline\hline
Hyperparameter & SP-BLRCR & LCMCR   \\ [0.5ex] 
\hline\hline
$a$                      & 0.25  & 0.25  \\ 
$b$                      & 0.25  & 0.25  \\ 
$\nu_0$                  & 3     &  \\ 
$\kappa_0$               & 1     &  \\ 
$\boldsymbol{\mu_0}$     & (0,0) &  \\ [1ex]
$\boldsymbol{\Lambda_0}$ & $\begin{bmatrix}
1 & 0 \\
0 & 1 
\end{bmatrix}$ &  \\
&&\\ [-0.25ex]
 \hline

\end{tabular}
\caption{Hyperparameter specifications for the SP-BLRCR and LCMCR algorithms.}
\label{table:hyperparams}
\end{table}

The following subsections run simulations on data generated from different characteristics including levels of list dependency (subsection \ref{Sec:simslistdepend}), size of population (subsection \ref{Sec:simspopsize}), various covariate distributions (subsection \ref{Sec:simscovdists}), and unobservable heterogeneity (subsection \ref{Sec:simsunobservedheterogeneity}).  The objective is to compare and contrast the BLRCR model with the other approaches described above. For each algorithm a point estimate of the population size, $N$, is computed. We have some options for what to use as the point estimate, $\hat{N}$, for the MCMC algorithms, but we elect to use median of the sampled posterior. In order to get a measure on the precision and accuracy model, we also compute the 95$\%$ confidence/credible interval.

In each subsection a table with results can be found. The column $N\%$ computes the average $\hat{N}$ across the simulations and takes it as a percentage of $N$.  Hence, a score of 1.000 would indicate an unbiased estimate. In addition, we consider the accuracy of the point estimate by computing the mean squared error (MSE) of the simulated $\hat{N}$. We also look to the accuracy of the $95\%$ interval estimate by checking whether $N$ fell inside that interval (CI$\%$). Of course, the precision of the interval must also be considered so we computed the average of the simulated 95$\%$ confidence/credible interval widths as a percentage of $N$ (CI Width).  Ideally, we would want a model with a small interval width (high precision) but maintains the ability to find the true population size often (high accuracy).


\subsection{Simulations with Varying Levels of List Dependency }
\label{Sec:simslistdepend}

The objective of this subsection is to evaluate the BLRCR and other models under varying coefficients that induce different levels of list dependency. All of this list dependency is really just heterogeneity in the capture probabilities that can be fully explained by the covariates. The models that do not use covariates (Log Linear, LCMCR, and Independent) will not or will struggle to detect the heterogeneity leading to biased results.  On the other hand, the BLRCR and cMLCR will perform well as they incorporate the covariates into their modelling.

We simulate data in accordance with \autoref{eqn:logitdatacreation} using two covariates ($H$=2) and four lists ($J=4$).  The covariates are drawn from two independent standard normal distributions.  Three sets of $\beta$ coefficients are chosen that create "negative", "moderate", and "positive" dependency between the lists and are described in \autoref{table:1}. To clarify, all of the lists regardless of the coefficients are conditionally independent given the covariates.  We simulate an additional dataset with all of the slope coefficients set to 0, thereby creating lists with independent capture probabilities.

\begin{table}[H]
\centering
\begin{tabular}{||c c c c||} 
 \hline
 \multicolumn{4}{||c||}{"Negative"}\\
 \hline
 List ($j$) & $\beta_{0j}$ & $\beta_{1j}$ & $\beta_{2j}$   \\ [0.5ex] 
 \hline\hline
 1 & -2 &  -1  & 1 \\ 
 2 & -2 & 1  &  -1 \\
 3 & -2 & 1  &  1 \\
 4 & -2 &  -1  &  -1 \\
 \hline
\end{tabular}
\begin{tabular}{||c c c c||} 
\hline
 \multicolumn{4}{||c||}{"Moderate"}\\
 \hline
 List ($j$) & $\beta_{0j}$ & $\beta_{1j}$ & $\beta_{2j}$   \\ [0.5ex] 
 \hline\hline
 1 & -2 &  -1  & 1 \\ 
 2 & -2 & 1  &  -1 \\
 3 & -2 & -1  &  1 \\
 4 & -2 &  1  &  -1 \\
 \hline
\end{tabular}
\begin{tabular}{||c c c c||} 
 \hline
 \multicolumn{4}{||c||}{"Positive"}\\
 \hline
 List ($j$) & $\beta_{0j}$ & $\beta_{1j}$ & $\beta_{2j}$   \\ [0.5ex] 
 \hline\hline
 1 & -2 &  -1  & 1 \\ 
 2 & -2 & -1  &  1 \\
 3 & -2 & -1  &  1 \\
 4 & -2 &  -1  &  1 \\
 \hline
\end{tabular}
\caption{Coefficients for Simulated Data}
\label{table:1}
\end{table}

```{r}
##################################
### Different Coefficients #######
##################################

##########
#Moderate#
##########
#Set N and BETA
myN=2000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```


\begin{table}[H]
\centering
\begin{tabular}{||r l r r r r||} 
 \hline
$\boldsymbol{\beta}$ & Method & N$\%$ &MSE & CI Width & CI $\%$   \\ [0.5ex] 
 \hline\hline
 "Moderate"    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               &  BLRCR($K=20$, $H_\omega=1$)   & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\                
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
               
```{r}
##########
#Negative#
##########
#Set N and BETA
myN=2000
myBeta="negative"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
                                  
 \hline
"Negative"    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
                              & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\                
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\
```{r}
##########
#Positive#
##########
#Set N and BETA
myN=2000
myBeta="positive"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
 \hline
 "Positive"    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\                
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
```{r}
#############
#Independent#
#############
#Set N and BETA
myN=2000
myBeta="independent"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
 \hline
 "Independent" & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\                
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
 \hline
\end{tabular}
\caption{Results of 100 capture-recapture simulations per coefficient set using $N=2000$ with "Moderate", "Negative", "Positive", and "Independent" list dependency with two standard normal covariates. }
\label{table:diffcoefs}
\end{table}

\autoref{table:diffcoefs} shows the results from 100 simulated datasets for each set of coefficients, $\beta$. While all of the models performed well when the slope coefficients were set to 0, i.e. "Independent", the methods using covariates (BLRCR and cMLRCR) showed substantially less bias than the other methods when coefficients impacted the capture probability, i.e. "Moderate", "Negative", and "Positive". This illustrates the importance of including covariates in the estimation process.  Nevertheless, the two methods that account for unknown heterogeneity, log linear and LCMCR, still performed remarkably well when the list dependency was set to be "negative."  Unfortunately, "positively" induced list dependency led to a substantial decline in performance.


\subsection{Simulations with Different Sized Populations}
\label{Sec:simspopsize}

In this subsection, we examine the effects of differing population sizes on the estimations with two objectives to evaluate in mind: performance and consistency. For the most part, we will see that all models will become less biased as the population size increases (except assuming independence). We will also see that using the BLRCR will tend to have a lower MSE than the cMLCR approach, especially with smaller population sizes.

Data was simulated with varying population sizes, $N=$[200,500,1000,2000,5000,10000], with the results summarized in \autoref{table:diffsizes}.  For consistency, all datasets were contructed using the coefficients yielding "moderate" dependency and with two standard normal covariates. Before examining the results, it should be pointed out that there were considerable issues with using the log linear approach with the smaller sample sizes.  While a point estimate was always able to be obtained, often times, the \texttt{Rcapture} package would simply report a lower bound on the upper limit of the confidence interval.  Instead of making a decision on whether to use that bound as the upper limit, we simply report the interval width as not available (NA).

With this consideration in mind, we highlight a few interesting observations. Most importantly, the BLRCR and cMLCR methods tended to outperform the other methods in terms of mean squared error (MSE), 95 $\%$ credible interval width (CI width), and the 95$\%$ credible interval capture percentage (CI $\%$). There were a handful of occasions where that was not the case but appears to be attributed to the choice of simulation parameters. Noteably, the independence model outperformed all other models when $N=1000$, but as the population grew, it became substantially worse and is actually the worst option when $N=10000$.  Additional simulations (not shown) performed with different sets of coefficients revealed the independence model to be a substantially worse choice than BLRCR regardless of population size. 

A comparison of the three BLRCR methods and cMLCR reveal relatively similar performances across population sizes.  Keep in mind, the simulation used in \autoref{table:diffcoefs} simply used a single multivariate normal with no heterogeneity. The additional noise of assuming an infinite mixture of normal distributions and/or heterogeneity in capture probabilities seems to have had little to no impact on the estimation.\autoref{fig:plotNvalues} shows a correlation plot between the 100 estimates for $N$ using the three BLRCR methods and cMLCR with the true population size set to $N=2000$.  Notice, the estimates are highly correlated, and BLRCR tends to return smaller estimated values than cMLCR. An important result of \cite{alho_logistic_1990}, is that the cMLCR estimator is consistent but may be biased with small sample sizes. From the simulations, it certainly appears this is true for N=200, but the level of bias quickly disappears with N=500 and above.  Similarly, the BLRCR seems to share this quality of consistency but the bias is greater albeit the opposite direction. Nevertheless, as we would expect with Bayesian methods, we are trading some bias for a reduction in variance.  The mean squared error (MSE) tends to be smaller than the other methods.

```{r}
##################################
######## Different Sizes #########
##################################

##########
#N = 200 #
##########
#Set N and BETA
myN=200
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"


#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```

\begin{table}[H]
\centering
\begin{tabular}{||r l r r r r||} 
 \hline
$N$ & Method & N$\%$ &MSE & CI Width & CI $\%$   \\ [0.5ex] 
 \hline\hline
 200    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
```{r}
##########
#N = 500 #
##########
#Set N and BETA
myN=500
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
500    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 


```{r}
##########
#N = 1000#
##########
#Set N and BETA
myN=1000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
1000    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=$, $H_\omega=20$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

```{r}
##########
#N = 2000#
##########
#Set N and BETA
myN=2000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
2000    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)   & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

```{r}
##########
#N = 5000#
##########
#Set N and BETA
myN=5000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
5000    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

```{r}
###########
#N = 10000#
###########
#Set N and BETA
myN=10000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
10000    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
\hline
\end{tabular}
\caption{Results of 100 capture-recapture simulations per varying population sizes using "Moderate" list dependency and two standard normal covariates. }
\label{table:diffsizes}
\end{table}


```{r plotNvalues, fig.align='center',fig.width=8,fig.height=6,fig.margin=TRUE,fig.cap="\\label{fig:normalx} Correlation Plot of the 100 estimates for N using BLRCR and cMLCR when simulating from two independent standard normal distributions with moderate dependency between lists and a true population size of N=2000."}
#Set N and BETA
myN=2000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Get estimates
BLRCRN = as.numeric(simdat[myindex,]$normBLRCR50)
HSPBLRCRN = as.numeric(simdat[myindex,]$HSPBLRCR50)
SPBLRCRN = as.numeric(simdat[myindex,]$SPBLRCR50)
cMLCRN = as.numeric(simdat[myindex,]$cMLCR)


Nestimates=data.frame("B1"=BLRCRN,
                      "B2"=SPBLRCRN,
                      "B3"=HSPBLRCRN,
                      "cMLCR"=cMLCRN)

lowerfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_point()+
    geom_abline(intercept=0,slope=1)
    #scale_x_continuous(limits = c(1750,2250))+
    #scale_y_continuous(limits = c(1750,2250))
}
ggpairs(Nestimates,
        columnLabels = c("BLRCR(K=1,Hw=1)",
                         "BLRCR(K=20,Hw=1)",
                         "BLRCR(K=20,Hw=20)",
                         "cMLCR"),
        rowLabels =    c("BLRCR(K=1,Hw=1)",
                         "BLRCR(K=20,Hw=1)",
                         "BLRCR(K=20,Hw=20)",
                         "cMLCR"),
        lower=list(continuous=wrap(lowerfun))) + theme_bw()
```



Overall, the BLRCR model is shown to be consistent.  It also tends to outperform or equally perform the other methods in terms of MSE, CI width, and CI$\%$. 


\subsection{Simulations using Different Covariate Distributions}
\label{Sec:simscovdists}

In this subsection, we examine the impact of different covariate distributions and how they impact the BLRCR model's estimation. Recall, the BLRCR requires the specification of a covariate distribution, whereas the cMLCR does not. Hence, as we will see below, a misspecification of the covariate distribution can lead to bias in the inference. This bias will be reduced when using a more flexible covariate distribution like the infinite mixture of normal distributions (K=20).

\autoref{table:diffdists} presents the results of 100 simulations for three different sets of covariate distributions.  The first set of simulations uses the two standard normal distributions seen in the previous subsections.  While the cMLCR algorithm is unbiased, all three specifications of the BLRCR algorithm yield a lower MSE. Since the distribution of the covariates is actually normal, it is not surprising that the BLRCR performs well with these simulations.  On the other hand, we would expect the second set of covariates, two independent chi-square(1) distributions, to be particularly challenging.  The chi-square distribution only has probability mass for nonnegative values, which creates an abrupt cutoff at 0. The third set of covariates includes two different Gamma distributions, Gamma(1,1) and Gamma(3,1).  This set of covariates cuts off abruptly on one axis at 0, but not the other.  We can therefore think of the three sets of covariates as "normal", "not normal", and "near/approximately normal", respectively.



```{r}
###########################################
##### Different Dists #####################
###########################################
#Set N and BETA
myN=2000
myBeta="moderate"
mycovariates="twonormalcovs"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates==mycovariates

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```



\begin{table}[H]
\centering
\begin{tabular}{||r l r r r r||} 
 \hline
Distribution & Method & N$\%$ &MSE & CI Width & CI $\%$   \\ [0.5ex] 
 \hline\hline
 Normal(0,1)   & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
 Normal(0,1)   & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

```{r}
###########################################
##### Different Dists #####################
###########################################
#Set N and BETA
myN=2000
myBeta="moderate"
mycovariates="twochisqcovs"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates==mycovariates

#test <- simdat[myindex,]

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
 \hline
 Chi-Square(1)   & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
 Chi-Square(1)   & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
                 & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

```{r}
###########################################
##### Different Dists #####################
###########################################
#Set N and BETA
myN=2000
myBeta="moderate"
mycovariates="twogammacovs"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates==mycovariates

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
 \hline
 Gamma(1,1)    & BLRCR($K=1$,$H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
 Gamma(3,1)    & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$,$H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
 \hline
\end{tabular}
\caption{Results of capture-recapture algorithms with simulations using different covariate distributions with "moderate" dependency between lists and N=2000.}
\label{table:diffdists}
\end{table}

As we saw in the previous section, the BLRCR algorithm handles the normally distributed covariates well.  For the chi-square distributed covariates, using a single multivariate normal for the covariates results in poor performance with with an approximate bias of 1.656$\%$ of $N$ when $N=2000$.  Even though the covariates are not normally distributed, modeling them as a mixture of normal distributions results in a substantial reduction in the bias for $N$.  \autoref{fig:covariatedists} illustrates why this may be the case through a partial plotting of the simulated covariates.  In all plots, the black dots represent the individuals that are captured at least once in a list. The blue dots represent the individuals that are missing.  In the first and second plot in each row, the individuals that are missing are simulated using the BLRCR($K=1$, $H_\omega=1$) and BLRCR($K=20$, $H_\omega=1$) algorithms, respectively.  The third panel shows the true missing individuals that are unknown to the algorithm.  With the chi-square distribution, there is no good way to fit a single normal variable that well represents the space.  As a result, many missing covariates are populated into low probability density areas resulting in an overestimate of the missing covariates.  On the other hand, the BLRCR($K=20$, $H_\omega=1$) with it's less rigid covariate assumption, populates the space much better.


```{r posteriornormalplots, fig.align='center',fig.width=9,fig.height=9.5,fig.margin=TRUE,fig.cap="\\label{fig:covariatedists}Posterior Distribution of X when simulating various covariate distributions with moderate dependency between lists and N=2000."}

par(mar=c(2,2,1.2,2))
layout(matrix(c(1,1,1,
                2,3,4,
                5,5,5,
                6,7,8,
                9,9,9,
                10,11,12),ncol=3,byrow=TRUE),heights=c(1,4.5,1,4.5,1,4.2))

#Bring in the Normal data
myobserveddata=readRDS("simdata/normal09272022/myobserveddata.rds")
mymissingdata=readRDS("simdata/normal09272022/mymissingdata.rds")
mydataALL=readRDS("simdata/normal09272022/mydataALL.rds")
SPBLRCR=readRDS("simdata/normal09272022/SPBLRCR.rds")
normBLRCR=readRDS("simdata/normal09272022/normBLRCR.rds")
nmis=nrow(mymissingdata)
nsamples=nrow(SPBLRCR$Xmis)
plot.new()
text(.5,.5,"Normal(0,1) and Normal(0,1) Covariate Distributions",cex=1.75,font=2)
plot(myobserveddata[,5:6],
     xlab="X1",ylab="X2",main="Simulated Posterior - BLRCR(K=1,Hw=1)",
     xlim=c(-4,4),ylim=c(-4,4),pch=16)
points(normBLRCR$Xmis[(nsamples-nmis):nsamples,],col="blue")
legend(-4,4,legend=c("Observed","Simulated Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)
plot(myobserveddata[,5:6],
     xlab="X1",ylab="X2",main="Simulated Posterior - BLRCR(K=20,Hw=1)",
     xlim=c(-4,4),ylim=c(-4,4),pch=16)
points(SPBLRCR$Xmis[(nsamples-nmis):nsamples,],col="blue")
legend(-4,4,legend=c("Observed","Simulated Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)
plot(myobserveddata[,5:6],xlab="X1",ylab="X2",main="True Population",
     xlim=c(-4,4),ylim=c(-4,4),pch=16)
points(mymissingdata[,5:6],col="blue")
legend(-4,4,legend=c("Observed","Actual Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)

#Bring in the Chi-Square data
plot.new()
text(0.5,0.5,"Chi-Square(1) and Chi-Square(1) Covariate Distributions",cex=1.75,font=2)
myobserveddata=readRDS("simdata/chisquare09272022/myobserveddata.rds")
mymissingdata=readRDS("simdata/chisquare09272022/mymissingdata.rds")
mydataALL=readRDS("simdata/chisquare09272022/mydataALL.rds")
SPBLRCR=readRDS("simdata/chisquare09272022/SPBLRCR.rds")
normBLRCR=readRDS("simdata/chisquare09272022/normBLRCR.rds")
nmis=nrow(mymissingdata)
nsamples=nrow(SPBLRCR$Xmis)
plot(myobserveddata[,5:6],
     xlab="X1",ylab="X2",main="Simulated Posterior - BLRCR(K=1,Hw=1)",
     xlim=c(-1,7),ylim=c(-1,7),pch=16)
points(normBLRCR$Xmis[(nsamples-nmis):nsamples,],col="blue")
legend(-1,7,legend=c("Observed","Simulated Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)
plot(myobserveddata[,5:6],
     xlab="X1",ylab="X2",main="Simulated Posterior - BLRCR(K=20,Hw=1)",
     xlim=c(-1,7),ylim=c(-1,7),pch=16)
points(SPBLRCR$Xmis[(nsamples-nmis):nsamples,],col="blue")
legend(-1,7,legend=c("Observed","Simulated Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)
plot(myobserveddata[,5:6],xlab="X1",ylab="X2",main="True Population",
     xlim=c(-1,7),ylim=c(-1,7),pch=16)
points(mymissingdata[,5:6],col="blue")
legend(-1,7,legend=c("Observed","Actual Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)

#Bring in the Gamma data
plot.new()
myobserveddata=readRDS("simdata/gamma09272022/myobserveddata.rds")
mymissingdata=readRDS("simdata/gamma09272022/mymissingdata.rds")
mydataALL=readRDS("simdata/gamma09272022/mydataALL.rds")
SPBLRCR=readRDS("simdata/gamma09272022/SPBLRCR.rds")
normBLRCR=readRDS("simdata/gamma09272022/normBLRCR.rds")
nmis=nrow(mymissingdata)
nsamples=nrow(SPBLRCR$Xmis)
text(0.5,0.5,"Gamma(3,1) and Gamma(1,1) Covariate Distributions",cex=1.75,font=2)
plot(myobserveddata[,5:6],
     xlab="X1",ylab="X2",main="Simulated Posterior - BLRCR(K=1,Hw=1)",
     xlim=c(-1,7),ylim=c(-1,7),pch=16)
points(normBLRCR$Xmis[(nsamples-nmis):nsamples,],col="blue")
legend(-1,7,legend=c("Observed","Simulated Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)
plot(myobserveddata[,5:6],
     xlab="X1",ylab="X2",main="Simulated Posterior - BLRCR(K=20,Hw=1)",
     xlim=c(-1,7),ylim=c(-1,7),pch=16)
points(SPBLRCR$Xmis[(nsamples-nmis):nsamples,],col="blue")
legend(-1,7,legend=c("Observed","Simulated Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)
plot(myobserveddata[,5:6],xlab="X1",ylab="X2",main="True Population",
     xlim=c(-1,7),ylim=c(-1,7),pch=16)
points(mymissingdata[,5:6],col="blue")
legend(-1,7,legend=c("Observed","Actual Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 4)

```


The parameters of the covariate distribution are sampled based on augmented covariates, not just the observed covariates.  This results in uncertainty regarding the ability for the algorithm to correctly identify the covariate distribution.  To put the algorithm to the test, we simulate an example with a mixture of three multivariate normal distributions.  We use a population of size 2000 and the "moderate" coefficients. The results of the 100 simulations can be found in \autoref{table:mixdist}.  Despite on average nearly 50$\%$ of observations being missing, the algorithm when allowing for up to $K=20$ mixture normal distributions performs well. Of course, the cMLCR outperforms the algorithm in terms of MSE, but the BLRCR (without also trying to account for heterogeneity) is more precise with a smaller average credible interal width.


```{r}
###########################################
####### Mixture Dists #####################
###########################################
#Set N and BETA
myN=2000
myBeta="moderate"
mycovariates="twomixture3normcovs"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates==mycovariates

#test=simdat[myindex,]
#mean(as.numeric(test$cBLRCR))

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```

\begin{table}[H]
\centering
\begin{tabular}{||r l r r r r||} 
 \hline
Distribution & Method & N$\%$ &MSE & CI Width & CI $\%$   \\ [0.5ex] 
 \hline\hline
 Mixture Normal& BLRCR($K=1$,$H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$,$H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$,$H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

 \hline
\end{tabular}
\caption{Results of capture-recapture algorithms with simulations using different covariate distributions with "moderate" dependency between lists.}
\label{table:mixdist}
\end{table}


A look at the simulated posterior of the covariates in \autoref{fig:mixx} shows once again the benefits of using the mixture of normal distributions.  Using a single multivariate normal results in an imputation of covariates in low probability mass spaces, especially between the lower two mixtures. When a mixture of normal distributions is used, the imputation of the covariates is fairly consistent with the true distribution.

```{r posteriormixtureplots, fig.align='center',fig.width=9,fig.height=4.5,fig.margin=TRUE,fig.cap="\\label{fig:mixx}Posterior Distribution of the missing X values using algorithm SP-BLRCR."}

#Bring in the Normal data
myobserveddata=readRDS("simdata/normmixture09302022/myobserveddata.rds")
mymissingdata=readRDS("simdata/normmixture09302022/mymissingdata.rds")
mydataALL=readRDS("simdata/normmixture09302022/mydataALL.rds")
SPBLRCR=readRDS("simdata/normmixture09302022/SPBLRCR.rds")
normBLRCR=readRDS("simdata/normmixture09302022/normBLRCR.rds")
nmis=nrow(mymissingdata)
N=nrow(mydataALL)
n=nrow(myobserveddata)
nsamples=nrow(SPBLRCR$Xmis)

##Create a plot##
par(mfrow=c(1,3))
mu1 <- c(2,2)   
mu2 <- c(0,0)
mu3 <- c(-2,-2)
Sigma1=matrix(c(0.5,.45,.45,0.5),2)
Sigma2=matrix(c(1,0,0,1),2)
Sigma3=matrix(c(0.5,-.35,-.35,0.5),2)
plot(myobserveddata[,5:6],
     xlab="X1",ylab="X2",main="BLRCR(K=1, Hw=1)",
     xlim=c(-5,5),ylim=c(-5,5),pch=16)
xmisposterior=normBLRCR$Xmis
points(xmisposterior[round(seq(1,10000,length.out=nmis),0),],col="blue")
lines(ellipse(Sigma1,centre=mu1,level=.75), col="blue")
lines(ellipse(Sigma2,centre=mu2,level=.75), col="blue")
lines(ellipse(Sigma3,centre=mu3,level=.75), col="blue")
lines(ellipse(Sigma1,centre=mu1,level=.90), col="green")
lines(ellipse(Sigma2,centre=mu2,level=.90), col="green")
lines(ellipse(Sigma3,centre=mu3,level=.90), col="green")
lines(ellipse(Sigma1,centre=mu1,level=.50), col="red")
lines(ellipse(Sigma2,centre=mu2,level=.50), col="red")
lines(ellipse(Sigma3,centre=mu3,level=.50), col="red")
legend(-5,5,legend=c("Observed","Simulated Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 5)
plot(myobserveddata[,5:6],
     xlab="X1",ylab="X2",main="BLRCR(K=20, Hw=1)",
     xlim=c(-5,5),ylim=c(-5,5),pch=16)
xmisposterior=SPBLRCR$Xmis
points(xmisposterior[round(seq(1,10000,length.out=nmis),0),],col="blue")
lines(ellipse(Sigma1,centre=mu1,level=.75), col="blue")
lines(ellipse(Sigma2,centre=mu2,level=.75), col="blue")
lines(ellipse(Sigma3,centre=mu3,level=.75), col="blue")
lines(ellipse(Sigma1,centre=mu1,level=.90), col="green")
lines(ellipse(Sigma2,centre=mu2,level=.90), col="green")
lines(ellipse(Sigma3,centre=mu3,level=.90), col="green")
lines(ellipse(Sigma1,centre=mu1,level=.50), col="red")
lines(ellipse(Sigma2,centre=mu2,level=.50), col="red")
lines(ellipse(Sigma3,centre=mu3,level=.50), col="red")
legend(-5,5,legend=c("Observed","Simulated Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 5)
plot(myobserveddata[,5:6],xlab="X1",ylab="X2",main="True Population",
     xlim=c(-5,5),ylim=c(-5,5),pch=16)
points(mymissingdata[,5:6],col="blue")
lines(ellipse(Sigma1,centre=mu1,level=.75), col="blue")
lines(ellipse(Sigma2,centre=mu2,level=.75), col="blue")
lines(ellipse(Sigma3,centre=mu3,level=.75), col="blue")
lines(ellipse(Sigma1,centre=mu1,level=.90), col="green")
lines(ellipse(Sigma2,centre=mu2,level=.90), col="green")
lines(ellipse(Sigma3,centre=mu3,level=.90), col="green")
lines(ellipse(Sigma1,centre=mu1,level=.50), col="red")
lines(ellipse(Sigma2,centre=mu2,level=.50), col="red")
lines(ellipse(Sigma3,centre=mu3,level=.50), col="red")
legend(-5,5,legend=c("Observed","Actual Missing"),
       col=c("black","blue"),pch=c(16,1),bg="lightblue",text.font=4,
       text.width = 5)

```

From this subsection, we saw that depending on the level of the covariate distribution misspecification, the BLRCR model may perform poorly. However, using a non-parametric distribution like the mixture of normal distributions considerably reduced the bias.

\subsection{Simulations with Unobserved Heterogeneity}
\label{Sec:simsunobservedheterogeneity}

The final set of simulations is to demonstrate the importance of accounting for both the observed and unobserved heterogeneity. While the cMLCR model has performed well in the prior sections, it has no method of detecting unobservable heterogeneity and hence produces biased estimation. Interestingly, a model like the LCMCR, which is designed to account for unobservable heterogeneity, performs much better, but still struggles as considerable information can be gained by including the covariates. The BLRCR model when extended to include latent intercepts ($H_\omega>1$) can utilize the covariates to detect the observable heterogeneity, but also accounts for the additional unobservable heterogeneity.  As a result, it is the only model that performs well in this subsection.

Data is simulated for three lists (J=3) with one standard normally distributed observed covariate (H=1) and one unobserved covariate indicating membership to a latent group with probability 0.35.  The coefficients used to simulate the data can be found in \autoref{table:heterocoefs}.  Using these coefficients induces positive dependency between lists 1 and 2, but negative dependency between list 3 and the other two lists.  If class membership were known, the list probabilities would still be conditionally independent; however, since these covariates are unobserved, the list probabilities are no longer conditionally independent given the observed data.

\begin{table}[H]
\centering
\begin{tabular}{||c c c c||} 
 \hline
 List ($j$) & $\beta_{0j}$ & $\beta_{1j}$ & $\beta_{\omega j}$   \\ [0.5ex] 
 \hline\hline
 1 & -2.5 &  -1.5  & 3.0 \\ 
 2 & -2.5 & -1.5  &  3.0 \\
 3 & 0.5 & -1.5  &  -3.0 \\
 \hline
\end{tabular}
\caption{Coefficients for Heterogeneity Simulated Data}
\label{table:heterocoefs}
\end{table}


\autoref{table:heterodist} shows the results of 100 simulations on four different population sizes.  It becomes obvious that not accounting for unobserved heterogeneity results in biased estimates for both the BLRCR and cMLCR models.  Recall, the truth with these simulations is there exists two latent classes.  Notice the BLRCR model with the number of hidden classes set at $H_\omega=2$ performs the best in terms of both accuracy and precision.  In a real setting, the number of hidden classes would almost certainly be unknown so we set a sufficiently large value $H_\omega=20$.  While the model doesn't perform quite as well as the aforementioned setting, it dramatically outperforms the methods that do not take unobserved heterogeneity into account.

For situations where observed and unobserved heterogeneity exist, we need a method that accounts for both. It should be noted that the LCMCR model, a methodology that doesn't use covariates, is outperforming the methods that do but assume conditional independence. The LCMCR model is designed to account for unobserved heterogeneity, and since the unobserved heterogeneity plays a substantial role in the capture probability for these simulations, it performs reasonably well. Of course, as we saw in the previous subsections' simulations, the LCMCR does not perform as well as the other methods when most of the heterogeneity can be explained by the covariates.

To further explore the effects of hidden heterogeneity and its detectability, we ran 100 simulations with different coefficients and group percentages.  Using the same coefficients in \autoref{table:heterocoefs}, but adjusting the absolute value of the coefficients, $\beta_{\omega_j}$, we created scenarious that depict different strength levels of heterogeneity.  Trivially, if the coefficient is 0, there is no unobserved heterogeneity in the capture probabilities.  In this situation the algorithm is simply detecting noise that it is mistaking for heterogeneity.  On the other hand, when the absolute value of the $\beta_{\omega j}$ coefficients are set to 5, there is very strong heterogeneity in the capture probabilities for the two groups.  The top plot in \autoref{fig:heterogeneitydiff} shows the mean square error (MSE) of the 100 simulations' posterior median of $N$. A close examination of the plot reveals an overall decrease in the MSE as the heterogeneity strengthens.  This is not surprising as the model is attempting to account for heterogeneity, but if it cannot detect the heterogeneity, it will induce bias.  When the heterogeneity is stronger, the model is more likely to detect this heterogeneity and account for it properly.  


\begin{table}[H]
\centering
\begin{tabular}{||r l r r r r||} 
 \hline
N & Method & N$\%$ &MSE & CI Width & CI $\%$   \\ [0.5ex] 
 \hline\hline

```{r}
#########################################################
####### Heterogeneity Distributions #####################
#########################################################
#Set N and BETA
myN=1000
myBeta="heterogeneity"
mycovariates="onenormwithheterocovs"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates==mycovariates

#test=simdat[myindex,]
#mean(as.numeric(test$cBLRCR))

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
HSPBLRCR2Nhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
HSPBLRC2RMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR2.50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
HSPBLRC2width = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
HSPBLRC2CI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR2.97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```

 1000          & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=2$)    & `r op(HSPBLRCR2Nhat,3)`     & `r op(HSPBLRC2RMSE,1)`     & `r op(HSPBLRC2width,3)`     & `r op(HSPBLRC2CI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\ 
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

 \hline
 
```{r}
#########################################################
####### Heterogeneity Distributions #####################
#########################################################
#Set N and BETA
myN=2000
myBeta="heterogeneity"
mycovariates="onenormwithheterocovs"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates==mycovariates

#test=simdat[myindex,]
#mean(as.numeric(test$cBLRCR))

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
HSPBLRCR2Nhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
HSPBLRC2RMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR2.50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
HSPBLRC2width = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
HSPBLRC2CI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR2.97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```

 2000          & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\
               & BLRCR($K=20$, $H_\omega=2$)    & `r op(HSPBLRCR2Nhat,3)`     & `r op(HSPBLRC2RMSE,1)`     & `r op(HSPBLRC2width,3)`     & `r op(HSPBLRC2CI,1)` \\
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\ 
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

 \hline
 
```{r}
#########################################################
####### Heterogeneity Distributions #####################
#########################################################
#Set N and BETA
myN=5000
myBeta="heterogeneity"
mycovariates="onenormwithheterocovs"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates==mycovariates

#test=simdat[myindex,]
#mean(as.numeric(test$cBLRCR))

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
HSPBLRCR2Nhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
HSPBLRC2RMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR2.50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
HSPBLRC2width = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
HSPBLRC2CI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR2.97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```

 5000          & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=2$)    & `r op(HSPBLRCR2Nhat,3)`     & `r op(HSPBLRC2RMSE,1)`     & `r op(HSPBLRC2width,3)`     & `r op(HSPBLRC2CI,1)` \\
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\ 
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

 \hline
 
```{r}
#########################################################
####### Heterogeneity Distributions #####################
#########################################################
#Set N and BETA
myN=10000
myBeta="heterogeneity"
mycovariates="onenormwithheterocovs"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates==mycovariates

#test=simdat[myindex,]
#mean(as.numeric(test$cBLRCR))

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
HSPBLRCR2Nhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
HSPBLRC2RMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR2.50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
HSPBLRC2width = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
HSPBLRC2CI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR2.97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```

 10000          & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=2$)    & `r op(HSPBLRCR2Nhat,3)`     & `r op(HSPBLRC2RMSE,1)`     & `r op(HSPBLRC2width,3)`     & `r op(HSPBLRC2CI,1)` \\
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\ 
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

 \hline
\end{tabular}
\caption{Results of 100 capture-recapture simulations per algorithm using a standard normal distribution distribution for the known covariate and 0.35 probability of belonging to the latent class.}
\label{table:heterodist}
\end{table}


```{r heterogeneitydiff, fig.align='center',fig.width=9,fig.height=7,fig.margin=TRUE,fig.cap="\\label{fig:strengthheterogeneitydiff}Effect of Strength of Heterogeneity on the Mean Square Error"}
diffleveldataset<-readRDS("simdata/heterogeneitylevelsdata.RDS")

#Edit the data to get MSE for group identification and N
diffleveldataset$sqdiff = (1-diffleveldataset$N50/5000)^2
diffleveldatasetLONG= cbind(rbind(diffleveldataset[,1:5],diffleveldataset[,1:5]),
                            "AME"=c(diffleveldataset[,9],diffleveldataset[,10]),
                            "param"=c(rep("Group Identity",1800),rep("Estimated N",1800)))

#diffleveldataset$intlength = (diffleveldataset$N97.5-diffleveldataset$N2.5)/5000
#aggregate(cbind(sqdiff,intlength)~beta+percgroup,diffleveldataset,mean)

aggdataframe = cbind(
  aggregate(AME~beta+percgroup+param,diffleveldatasetLONG,mean),
  "lower"=aggregate(AME~beta+percgroup+param,diffleveldatasetLONG,function(x){quantile(x,c(0.025),names=FALSE)})[,4],
  "upper"=aggregate(AME~beta+percgroup+param,diffleveldatasetLONG,function(x){quantile(x,c(0.975),names=FALSE)})[,4])

#do this to truncate the upper limits of the N mse (remove if not desired)
#aggdataframe$upper[which(aggdataframe$upper>.0075&aggdataframe$param=="Estimated N")] = .0075

aggdataframe$beta = as.factor(aggdataframe$beta)
aggdataframe$percgroup = as.factor(aggdataframe$percgroup)
pd=position_dodge(0.2)
par(mfrow=c(1,2))
ggplot(aggdataframe, aes(x=beta, y=AME, group=percgroup,color=percgroup)) + 
  facet_grid(param~.,scales="free") +
  geom_point(position=pd, size=3) +
  geom_line(position=pd, size=1) +
  geom_pointrange(aes(ymin=lower, ymax=upper), size=1,position=pd) +
  xlab("Strength of Heterogeneity") +
  ylab("Mean Square Error") +
  scale_colour_hue(name="Percentage in Group 1",    
                   breaks=c("0.1", "0.3", "0.5"),
                   labels=c("0.1", "0.3", "0.5"),
                   l=30) +  
  theme_classic() +
  theme(legend.justification=c(1,0),
        legend.position=c(.95,.75))      
```

The bottom plot in \autoref{fig:heterogeneitydiff} shows the MSE of the average posterior group identifier for the observed data.  In other words, if the first observation actually belongs to the hidden group, $\omega_1$=1, then we find the average number of times the algorithm placed the observation in the first group, $\bar{\omega}_1$.  In the binary case, $H_\omega=2$, the MSE can be computed as

\begin{equation}
MSE = \frac{1}{n}\sum_{i=1}^n (\bar{\omega}_{i} - \omega_i)^2.
\end{equation}

As the heterogeneity strengthens, the detectability of the unobserved groupings increases and the MSE drops considerably.  In the case where the absolute value of $\beta_{\omega j}$ is set to 5, in many of the simulations between 90 and 95$\%$ of the observations are detected correctly in over 90$\%$ of posterior samples.

Unobserved heterogeneity creates a trade off.  On one hand, if the unobserved heterogeneity is weak, there will be relatively little bias in $N$; however, the ability to detect this heterogeneity decreases as well.  On the other hand, When the unobserved heterogeneity is strong, the bias in $N$ will be relatively larger, but the ability to detect and properly account for this heterogeneity increases. 


