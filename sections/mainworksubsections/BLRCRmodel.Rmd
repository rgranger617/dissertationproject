---
title: ''
output: pdf_document
---


<!--------------------------------------------------------->
<!---------- Bayesian logistic Regression Section --------->
<!--------------------------------------------------------->

\subsection{The Bayesian Logistic Regression Capture-Recapture Model}
\label{Sec:BLRCRmodel}

\subsubsection{The BLRCR Model}

Using the framework from subsection \ref{sec:CRwithcovariates}, we implement the Bayesian Logistic Regression Capture-Recapture (BLRCR) model which uses independent logistic regressions to estimate the capture probabilities on each list. Suppose $y_{ij}$ and $x_{ih}$ are generated in the following way:

\begin{align} 
\label{eqn:logitdatacreation}
y_{ij}|\boldsymbol{x_i}& \stackrel{ind}{\sim} \text{Bernoulli}(\lambda_{ij}(\boldsymbol{x_i})) \hspace{10px} \text{for } i=1,...,N \text{ and } j=1,...,J\\  
\boldsymbol{x_{i}} & \stackrel{iid}{\sim} \boldsymbol{g}(\boldsymbol{\phi}) \hspace{10px} \text{for } i=1,...,N,
\end{align}

where

\begin{equation}
\label{eqn:sigmoidfunc}
\lambda_{ij}(\boldsymbol{x_i})=\sigma(\boldsymbol{x_i}^T\boldsymbol{\beta_j}) = \frac{1}{1+e^{-\boldsymbol{x_i}^T\boldsymbol{\beta_j}}},
\end{equation}

and $\boldsymbol{g}(\boldsymbol{\phi})$ is the distribution of the $H$ covariates.  The capture probability that individual $i$ appears on list $j$ is equal to $\lambda_{ij}$, and this value can be calculated with a nonstochastic transformation of $\boldsymbol{x_i}$ and $\boldsymbol{\beta_j}$ through the sigmoid function (see \autoref{eqn:sigmoidfunc}). In the linear term, $\boldsymbol{x_i}^T\boldsymbol{\beta_j}$, a different set of $\boldsymbol{\beta_j}$ covariates are used to determine each $\lambda_{ij}$ implying a total of $k\times(h+1)$ coefficients with the inclusion of an intercept.  Notice this setup implies each individual's capture pattern is independent conditional on the covariates, i.e, $p(\boldsymbol{y_i}|\boldsymbol{x_i}) = \prod_{i=j}^J p(y_{ij}|x_{i},\theta)$. 

\cite{king_capturerecapture_2016} proposes a similar model in their first example titled "Continuous individual covariates." An important distinction though is the allowance, for each covariate, to have a different set of coefficients, $\boldsymbol{\beta_j}$. \cite{king_capturerecapture_2016} justifies a single coefficient per covariate as the model they develop is in the context of animal populations. In animal populations, each list is a different capturing from the same population but at various time points. In order to assume a closed population, the lists should be collected in a relatively short time period. As a result, the author argues that any time varying effect from the covariates should be limited. On the other hand, we approach this problem in the context of human populations, where lists are not necessarily different time points but instead different data collectors or databases. As a result, we expect individual characteristics (covariates) to have different impacts on the capture probability depending on the list.

In order to complete the Bayesian model, priors must be assigned to unknown parameters $N$, $\boldsymbol{\beta_j}$, and $\boldsymbol{\phi_h}$. For $N$, we use the Jeffrey's prior \citep{jeffreys_theory_1967}, $p(N) = \frac{1}{N}$, which conveniently results in a negative binomial distribution for the conditional posterior distribution of $N$. Other choices of priors typically result in more complicated estimation, especially with data augmentation (see \cite{king_capturerecapture_2016} for a discussion). For the $\boldsymbol{\beta_j}$ coefficients, we assign a multivariate normal prior to the set of coefficients for each list with mean of $\boldsymbol{b}\in \mathcal{R}^{H+1}$ and covariance of $\boldsymbol{B}\in \mathcal{R}^{(H+1) \times (H+1)}$. Other choices of prior can be used as the problem reduces to Bayesian logistic regression after augmenting the missing data. We select the multivariate normal prior as it is the same prior used in the Bayesian logistic regression Monte Carlo Markov Chain (MCMC) sampling scheme proposed in \citep{polson_bayesian_2013}, which makes implementation simple. We can be flexible in our choice of prior distribution for the $\boldsymbol{\beta_j}$ coefficients as long as a suitable method exists for drawing samples from the conditional posterior distribution for $\boldsymbol{\beta_j}$. Lastly, for now, assume $\boldsymbol{\phi_h}$ is known and thus can be treated as a hyperparameter (this will be further addressed in subsection \ref{Sec:selectcovariates}).

Plugging in the likelihood distribution as described in \autoref{eqn:logitdatacreation} and the aforementioned priors into \autoref{eqn:fullposteriorderive} yields the posterior
\begin{align}
\label{eqn:fullposteriorderivevalues}
\nonumber p(N,\boldsymbol{\beta},\mathcal{X}_{mis}|\mathcal{Y}_{obs},\mathcal{X}_{obs}) \propto &  \left[\binom{N}{n}\prod_{i=1}^n \prod_{j=1}^J \lambda_{ij}(\boldsymbol{x_i})^{y_{ij}}(1-\lambda_{ij}(\boldsymbol{x_i}))^{1-y_{ij}}\prod_{i=n+1}^N \prod_{j=1}^J (1-\lambda_{ij}(\boldsymbol{x_i})) \right] \\
\nonumber \times & \left[ \prod_{i=1}^n \boldsymbol{g}(\boldsymbol{x_i}|\boldsymbol{\phi_h}) \right] \times \left[ \prod_{i=n+1}^N \boldsymbol{g}(\boldsymbol{x_i}|\boldsymbol{\phi_h}) \right] \times \left[\frac{1}{N}\right] \\
\times & \left[ \prod_{j=1}^J \left(\frac{1}{2\pi}\right)^{H/2}|\boldsymbol{B}|^{-1/2}e^{-\frac{1}{2}(\boldsymbol{b}-\boldsymbol{\beta_j})^T\boldsymbol{B}^{-1}(\boldsymbol{b}-\boldsymbol{\beta_j})}\right].
\end{align}


<!--------------------------------------------------------->
<!---------------- Estimation of the BLRCR ---------------->
<!--------------------------------------------------------->


\subsubsection{Estimation of the BLRCR}
\label{sec:estimationBLRCRMCMC}

An exact analytic solution for the posterior is intractable, so we implement the MCMC algorithm of Gibbs Sampling, where sequential draws from $\boldsymbol{\beta}$, $N$, and $\mathcal{X}_{mis}$ are taken conditional on all other parameters.

\begin{list}{}{}

\item[1)] Sample $\boldsymbol{\beta}$.  For this stage $\mathcal{X}_{mis}$ and $\mathcal{X}_{obs}$ are both known implying $N$ is known as well.  Therefore the sampling equation reduces to 
\begin{equation}
\label{eqn:conditionalbeta}
p(\boldsymbol{\beta}|\mathcal{Y},N,\mathcal{X}_{mis},\mathcal{X}_{obs}) = p(\boldsymbol{\beta}|\mathcal{Y},\mathcal{X}), 
\end{equation}
which is simply the posterior distribution of Bayesian logistic regression.   Posterior samples can be obtained from \autoref{eqn:conditionalbeta} by first sampling a latent variable from the Polya-Gamma distribution and using this latent variable in the mean and covariance function of a multivariate normal \citep{polson_bayesian_2013}.

\item[2)] Sample $N$ and $\mathcal{X}_{mis}$.  Adding up the number of missing covariates, $n_0$, with the number of observed covariates, $n$, fully determines $N=n_0+n$.  This issue makes it impossible to compute the standard Gibbs sampling equation for $N$.  To get around this complication, we sample the parameters simultaneously \citep{basu_bayesian_2001},

\begin{equation}
\label{eqn:gibbsNandXmis}
p(N,\mathcal{X}_{mis}|\mathcal{Y},\boldsymbol{\beta},\mathcal{X}_{obs})\propto p(N|\mathcal{Y},\boldsymbol{\beta},\mathcal{X}_{obs})p(\mathcal{X}_{mis}|N,\mathcal{Y},\boldsymbol{\beta},\mathcal{X}_{obs}).
\end{equation}

From \autoref{eqn:gibbsNandXmis}, observe the joint distribution of $N$ and $\mathcal{X}_{obs}$ can be decomposed into two parts from which can be sampled.  The first part of this equation is the joint distribution of $N$ and $\mathcal{X}_{mis}$ marginalized over the missing covariates.  The second part is the distribution of the missing covariates where the number of missing covariates, $n_0$, is known.

\begin{list}{}{}
  \item[i.] Sample $N \sim  p(N|\mathcal{Y},\boldsymbol{\beta},\mathcal{X}_{obs})$. 
    \begin{align}
    \label{eqn:deriveNdistribution}
    \nonumber p(N|\mathcal{Y},\boldsymbol{\beta},\mathcal{X}_{obs}) & = \int_{\boldsymbol{x_{n+1}}} \hspace{-10px}\cdots    \int_{\boldsymbol{x_{N}}} p(N,\mathcal{X}_{mis}|\mathcal{Y},\boldsymbol{\beta},\mathcal{X}_{obs}) d\boldsymbol{x_{n+1}}\cdots d\boldsymbol{x_{N}}\\
\nonumber    & \propto \int_{\boldsymbol{x_{n+1}}} \hspace{-10px}\cdots \int_{\boldsymbol{x_{N}}}\left[\binom{N}{n} \prod_{i=n+1}^N \prod_{j=1}^J (1-\lambda_{ij}) \right]\left[ \prod_{i=n+1}^N\boldsymbol{g}(\boldsymbol{x_i}|\boldsymbol{\phi}) \right]\left[\frac{1}{N}\right]d\boldsymbol{x_{n+1}}\cdots d\boldsymbol{x_{N}}\\
\nonumber    & = \frac{(N-1)!}{(N-n)!n!} \left[ \int_{\boldsymbol{x}}\boldsymbol{g}(\boldsymbol{x_i}|\boldsymbol{\phi})\prod_{j=1}^J (1-\lambda_{ij}) d\boldsymbol{x}\right]^{N-n}\\
    & \propto \binom{N-1}{n-1} \left[\underbrace{ E_{\boldsymbol{g}(\boldsymbol{\theta_h})}\left[\prod_{j=1}^J (1-\lambda_{ij})\right]}_{\equiv \rho} \right]^{N-n}
    \end{align}
    
Instead of sampling $N$, sample $n_0 = N - n$.
    
    \vspace{-20px}
    
    \begin{align}
    \label{eqn:deriven0distribution}
\nonumber    p(n_0|\mathcal{Y},\boldsymbol{\beta},\mathcal{X}_{obs}) \propto & \binom{n_0 + n -1}{n-1}\rho^{n_0} \\
\nonumber \propto & \binom{n_0 + n -1}{n-1} \rho^{n_0} \underbrace{(1-\rho)^{n}}_{\text =constant}\\
=& \text{NegativeBinomial}(n, 1-\rho).
    \end{align}
    
The distribution of $n_0$ follows a negative binomial with parameter $n$ for the number of "successes" and $1-p$ as the "success" rate.  In this context, a "success" is defined as an observation being unobserved.  The value of $\rho$ is defined in \autoref{eqn:deriveNdistribution} and can be computed via numerical integration or estimated via a Monte Carlo within MCMC step as in \cite{bonner_mcmcmc_2014}.  After computing $\rho$ and sampling $n_0$ through \autoref{eqn:deriven0distribution}, find $N = n_0 + n$.
    
  
  \item[ii.] Sample $\mathcal{X}_{mis}$.   The missing observation, $\boldsymbol{x_i}$, is drawn independently of all other covariates, so $\boldsymbol{x_i}$ does not depend on any other $\boldsymbol{x_i} \in \mathcal{X}_{obs}\cup \mathcal{X}_{mis} $.  Also, by definition, if $\boldsymbol{x_i} \in \mathcal{X}_{mis}$, then $\boldsymbol{y_i} = \boldsymbol{0}$. Therefore, the distribution to be sampled is
  \begin{align}
  \label{eqn:conditionalXmis}
  \nonumber p(\boldsymbol{x_i}|N,\mathcal{Y},\boldsymbol{\beta},\mathcal{X}_{obs})&=p(\boldsymbol{x_i} |\boldsymbol{y_i}=\boldsymbol{0},\boldsymbol{\beta})\\
  &\propto \boldsymbol{g}(\boldsymbol{x_i}|\boldsymbol{\phi})\prod_{j=1}^J (1-\lambda_{ij}(\boldsymbol{x_i}))
  \end{align}
To sample from \autoref{eqn:conditionalXmis}, we use rejection sampling of a truncated distribution.  To do this, first draw a sample $\boldsymbol{x_i}$ from the distribution of the covariates, $\boldsymbol{g}(\boldsymbol{\phi})$. Next, accept the sample with probability of $\boldsymbol{x_i}$ being missing, i.e, $\prod_{j=1}^J (1-\lambda_{ij}(\boldsymbol{x_i}))$.  If the sample is not accepted, reject it, and draw another sample from $\boldsymbol{g}(\boldsymbol{\phi})$. Repeat this until we obtain $n_0 = N - n$ missing covariates.  On average, this sampling techniques requires us to draw $N$ total covariates for each sample.
  
  \end{list}
  
  

\end{list}

<!--------------------------------------------------------->
<!--------------- Simulations of the BLRCR ---------------->
<!--------------------------------------------------------->

\subsubsection{Simulation Analysis}
\label{Sec:simulationanalysis}

```{r simulatedata}
library(mvtnorm) #needed for multivariate normal
library(MCMCpack) #needed for inverse wishart
library(BayesLogit) #pollygamma sampling
library(cubature) #numerical integration
library(MASS)
library(LCMCR)
library(ellipse) #helpful for plotting ellipses
library(ggplot2)
library(GGally)
library(dplyr)

RMSE <- function(x,N){
  sqrt(mean((x-N)^2))
}

#Load simdata
simdat<-readRDS("simdata/simdata11122022.rds")
simdat=simdat[complete.cases(simdat),]
simdat$N = as.numeric(simdat$N)
simdat$n = as.numeric(simdat$n)


#remove NA
#simdat=simdat[-which(is.na(simdat$N)),]
```

In this section, we run numerous simulations covering a number of different types of situations including varying levels of list dependency, sizes of population, non-normal covariate distributions, and unobservable heterogeneity. The primary objective is to examine the results of the Bayesian Logistic Regression Capture-Recapture (BLRCR) model. Along with the BLRCR algorithm, we compare our results using four other capture-recapture algorithms. The first algorithm we use is conditional maximum likelihood logistic regression (cMLCR) which is implemented using the \texttt{VGAM} package in \texttt{R} (see subsection \ref{Sec:selectcovariates}).  Instead of using the asymptotic estimates for the standard error and assuming normality, we use a semiparametric bootstrap for the confidence intervals \citep{zwane_implementing_2003}. Second, we implement the ubiquitous hierarchical log-linear (Log Linear) modelling technique \citep{fienberg_multiple_1972} using the the \texttt{Rcapture} package in \texttt{R}. Keep in mind that this approach does not use covariates, but attempts to model list dependency directly through list interactions. Since the approach is hierarchical with $2^J$ different model constructions, all are calculated and the one with the lowest BIC is selected. Third, we use the Bayesian Non-Parametric Latent-Class Capture-Recapture (LCMCR) algorithm in \cite{manriquevallier_bayesian_2016} which is another technique that does not allow covariates but uses a Bayesian nonparametric approach to account for unobserved heterogeneity (see appendix \ref{LCMCRmodel} for a summary of this approach). The fourth technique is a simple independence model (Independent) where it is assumed there is no list or individual heterogeneity. Conveniently, when the number of latent classes is set equal to one, the LCMCR model collapses into an independence model, effectively giving a Bayesian independence sampler (Independent).

We estimate $N$ using the BLRCR model under three different specifications.  First, we consider a single multivariate normal to describe the covariate distribution ($K=1$) and no hidden heterogeneity ($H_\omega$=1).  Second, we allow for a mixture of multivariate normal distributions under the stick-breaking prior with a sufficiently large number of classes, $K=20$, but still do not allow for additional unobserved heterogeneity.  The third specification is similar to the second but now allows hidden heterogeneity with up to $H_\omega=20$ different latent intercepts. Also, the BLRCR model requires a prior mean and covariance for the coefficients, which are set to $$\boldsymbol{b}=\boldsymbol{0} \text{ and } \boldsymbol{B}=\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1
\end{bmatrix}.$$

In addition to priors on the coefficients, BLRCR and LCMCR require additional hyperparameter specifications for the mixture distributions which can be found in \autoref{table:hyperparams}.  The number of samples in each simulation for each algorithm is set to 10,000 unless otherwise stated. 


\begin{table}[H]
\centering
\begin{tabular}{||r r r||} 
\hline
& \multicolumn{2}{ c |}{Algorithm}\\
\hline\hline
Hyperparameter & SP-BLRCR & LCMCR   \\ [0.5ex] 
\hline\hline
$a$                      & 0.25  & 0.25  \\ 
$b$                      & 0.25  & 0.25  \\ 
$\nu_0$                  & 3     &  \\ 
$\kappa_0$               & 1     &  \\ 
$\boldsymbol{\mu_0}$     & (0,0) &  \\ [1ex]
$\boldsymbol{\Lambda_0}$ & $\begin{bmatrix}
1 & 0 \\
0 & 1 
\end{bmatrix}$ &  \\
&&\\ [-0.25ex]
 \hline

\end{tabular}
\caption{Hyperparameter specifications for the SP-BLRCR and LCMCR algorithms.}
\label{table:hyperparams}
\end{table}

The following subsections run simulations on data generated from different characteristics including levels of list dependency (subsection \ref{Sec:simslistdepend}), size of population (subsection \ref{Sec:simspopsize}), various covariate distributions (subsection \ref{Sec:simscovdists}), and unobservable heterogeneity (subsection \ref{Sec:simsunobservedheterogeneity}).  The objective is to compare and contrast the BLRCR model with the other approaches described above. For each algorithm a point estimate of the population size, $N$, is computed. We have some options for what to use as the point estimate, $\hat{N}$, for the MCMC algorithms, but we elect to use median of the sampled posterior. In order to get a measure on the precision and accuracy model, we also compute the 95$\%$ confidence/credible interval.

In each subsection a table with results can be found. The column $N\%$ computes the average $\hat{N}$ across the simulations and takes it as a percentage of $N$.  Hence, a score of 1.000 would indicate an unbiased estimate. In addition, we consider the accuracy of the point estimate by computing the mean squared error (MSE) of the simulated $\hat{N}$. We also look to the accuracy of the $95\%$ interval estimate by checking whether $N$ fell inside that interval (CI$\%$). Of course, the precision of the interval must also be considered so we computed the average of the simulated 95$\%$ confidence/credible interval widths as a percentage of $N$ (CI Width).  Ideally, we would want a model with a small interval width (high precision) but maintains the ability to find the true population size often (high accuracy).

\subsubsection{Simulations with Varying Levels of List Dependency }
\label{Sec:simslistdepend}

The objective of this subsection is to evaluate the BLRCR and other models under varying coefficients that induce different levels of list dependency. All of this list dependency is really just heterogeneity in the capture probabilities that can be fully explained by the covariates. The models that do not use covariates (Log Linear, LCMCR, and Independent) will not or will struggle to detect the heterogeneity leading to biased results.  On the other hand, the BLRCR and cMLCR will perform well as they incorporate the covariates into their modelling.

We simulate data in accordance with \autoref{eqn:logitdatacreation} using two covariates ($H$=2) and four lists ($J=4$).  The covariates are drawn from two independent standard normal distributions.  Three sets of $\beta$ coefficients are chosen that create "negative", "moderate", and "positive" dependency between the lists and are described in \autoref{table:1}. To clarify, all of the lists regardless of the coefficients are conditionally independent given the covariates.  We simulate an additional dataset with all of the slope coefficients set to 0, thereby creating lists with independent capture probabilities.

\begin{table}[H]
\centering
\begin{tabular}{||c c c c||} 
 \hline
 \multicolumn{4}{||c||}{"Negative"}\\
 \hline
 List ($j$) & $\beta_{0j}$ & $\beta_{1j}$ & $\beta_{2j}$   \\ [0.5ex] 
 \hline\hline
 1 & -2 &  -1  & 1 \\ 
 2 & -2 & 1  &  -1 \\
 3 & -2 & 1  &  1 \\
 4 & -2 &  -1  &  -1 \\
 \hline
\end{tabular}
\begin{tabular}{||c c c c||} 
\hline
 \multicolumn{4}{||c||}{"Moderate"}\\
 \hline
 List ($j$) & $\beta_{0j}$ & $\beta_{1j}$ & $\beta_{2j}$   \\ [0.5ex] 
 \hline\hline
 1 & -2 &  -1  & 1 \\ 
 2 & -2 & 1  &  -1 \\
 3 & -2 & -1  &  1 \\
 4 & -2 &  1  &  -1 \\
 \hline
\end{tabular}
\begin{tabular}{||c c c c||} 
 \hline
 \multicolumn{4}{||c||}{"Positive"}\\
 \hline
 List ($j$) & $\beta_{0j}$ & $\beta_{1j}$ & $\beta_{2j}$   \\ [0.5ex] 
 \hline\hline
 1 & -2 &  -1  & 1 \\ 
 2 & -2 & -1  &  1 \\
 3 & -2 & -1  &  1 \\
 4 & -2 &  -1  &  1 \\
 \hline
\end{tabular}
\caption{Coefficients for Simulated Data}
\label{table:1}
\end{table}

```{r}
##################################
### Different Coefficients #######
##################################

##########
#Moderate#
##########
#Set N and BETA
myN=2000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```


\begin{table}[H]
\centering
\begin{tabular}{||r l r r r r||} 
 \hline
$\boldsymbol{\beta}$ & Method & N$\%$ &MSE & CI Width & CI $\%$   \\ [0.5ex] 
 \hline\hline
 "Moderate"    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               &  BLRCR($K=20$, $H_\omega=1$)   & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\                
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
               
```{r}
##########
#Negative#
##########
#Set N and BETA
myN=2000
myBeta="negative"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
                                  
 \hline
"Negative"    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
                              & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\                
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\
```{r}
##########
#Positive#
##########
#Set N and BETA
myN=2000
myBeta="positive"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
 \hline
 "Positive"    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\                
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
```{r}
#############
#Independent#
#############
#Set N and BETA
myN=2000
myBeta="independent"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
 \hline
 "Independent" & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\                
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
 \hline
\end{tabular}
\caption{Results of 100 capture-recapture simulations per coefficient set using $N=2000$ with "Moderate", "Negative", "Positive", and "Independent" list dependency with two standard normal covariates. }
\label{table:diffcoefs}
\end{table}

\autoref{table:diffcoefs} shows the results from 100 simulated datasets for each set of coefficients, $\beta$. While all of the models performed well when the slope coefficients were set to 0, i.e. "Independent", the methods using covariates (BLRCR and cMLRCR) showed substantially less bias than the other methods when coefficients impacted the capture probability, i.e. "Moderate", "Negative", and "Positive". This illustrates the importance of including covariates in the estimation process.  Nevertheless, the two methods that account for unknown heterogeneity, log linear and LCMCR, still performed remarkably well when the list dependency was set to be "negative."  Unfortunately, "positively" induced list dependency led to a substantial decline in performance.


\subsubsection{Simulations with Different Sized Populations}
\label{Sec:simspopsize}

In this subsection, we examine the effects of differing population sizes on the estimations with two objectives to evaluate in mind: performance and consistency. For the most part, we will see that all models will become less biased as the population size increases (except assuming independence). We will also see that using the BLRCR will tend to have a lower MSE than the cMLCR approach, especially with smaller population sizes.

Data was simulated with varying population sizes, $N=$[200,500,1000,2000,5000,10000], with the results summarized in \autoref{table:diffsizes}.  For consistency, all datasets were contructed using the coefficients yielding "moderate" dependency and with two standard normal covariates. Before examining the results, it should be pointed out that there were considerable issues with using the log linear approach with the smaller sample sizes.  While a point estimate was always able to be obtained, often times, the \texttt{Rcapture} package would simply report a lower bound on the upper limit of the confidence interval.  Instead of making a decision on whether to use that bound as the upper limit, we simply report the interval width as not available (NA).

With this consideration in mind, we highlight a few interesting observations. Most importantly, the BLRCR and cMLCR methods tended to outperform the other methods in terms of mean squared error (MSE), 95 $\%$ credible interval width (CI width), and the 95$\%$ credible interval capture percentage (CI $\%$). There were a handful of occasions where that was not the case but appears to be attributed to the choice of simulation parameters. Noteably, the independence model outperformed all other models when $N=1000$, but as the population grew, it became substantially worse and is actually the worst option when $N=10000$.  Additional simulations (not shown) performed with different sets of coefficients revealed the independence model to be a substantially worse choice than BLRCR regardless of population size. 

A comparison of the three BLRCR methods and cMLCR reveal relatively similar performances across population sizes.  Keep in mind, the simulation used in \autoref{table:diffcoefs} simply used a single multivariate normal with no heterogeneity. The additional noise of assuming an infinite mixture of normal distributions and/or heterogeneity in capture probabilities seems to have had little to no impact on the estimation.\autoref{fig:plotNvalues} shows a correlation plot between the 100 estimates for $N$ using the three BLRCR methods and cMLCR with the true population size set to $N=2000$.  Notice, the estimates are highly correlated, and BLRCR tends to return smaller estimated values than cMLCR. An important result of \cite{alho_logistic_1990}, is that the cMLCR estimator is consistent but may be biased with small sample sizes. From the simulations, it certainly appears this is true for N=200, but the level of bias quickly disappears with N=500 and above.  Similarly, the BLRCR seems to share this quality of consistency but the bias is greater albeit the opposite direction. Nevertheless, as we would expect with Bayesian methods, we are trading some bias for a reduction in variance.  The mean squared error (MSE) tends to be smaller than the other methods.

```{r}
##################################
######## Different Sizes #########
##################################

##########
#N = 200 #
##########
#Set N and BETA
myN=200
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"


#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```

\begin{table}[H]
\centering
\begin{tabular}{||r l r r r r||} 
 \hline
$N$ & Method & N$\%$ &MSE & CI Width & CI $\%$   \\ [0.5ex] 
 \hline\hline
 200    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
```{r}
##########
#N = 500 #
##########
#Set N and BETA
myN=500
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
500    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 


```{r}
##########
#N = 1000#
##########
#Set N and BETA
myN=1000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
1000    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=$, $H_\omega=20$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

```{r}
##########
#N = 2000#
##########
#Set N and BETA
myN=2000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
2000    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)   & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

```{r}
##########
#N = 5000#
##########
#Set N and BETA
myN=5000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
5000    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 

```{r}
###########
#N = 10000#
###########
#Set N and BETA
myN=10000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Compute Percentage of N
HSPBLRCRNhat = mean(as.numeric(simdat[myindex,]$HSPBLRCR50))/myN
SPBLRCRNhat = mean(as.numeric(simdat[myindex,]$SPBLRCR50))/myN
normBLRCRNhat = mean(as.numeric(simdat[myindex,]$normBLRCR50))/myN
cMLCRNhat = mean(as.numeric(simdat[myindex,]$cMLCR))/myN
cBLRCRNhat = mean(as.numeric(simdat[myindex,]$cBLRCR))/myN
LCMCRNhat = mean(as.numeric(simdat[myindex,]$LCMCR50))/myN
loglinNhat = mean(as.numeric(simdat[myindex,]$loglin50))/myN
IndependentNhat = mean(as.numeric(simdat[myindex,]$Independent50))/myN

#Check RMSE
HSPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$HSPBLRCR50),myN)
SPBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$SPBLRCR50),myN)
normBLRCRMSE = RMSE(as.numeric(simdat[myindex,]$normBLRCR50),myN)
cMLCRRMSE = RMSE(as.numeric(simdat[myindex,]$cMLCR),myN)
cBLRCRRMSE = RMSE(as.numeric(simdat[myindex,]$cBLRCR),myN)
LCMCRRMSE = RMSE(as.numeric(simdat[myindex,]$LCMCR50),myN)
loglinRMSE = RMSE(as.numeric(simdat[myindex,]$loglin50),myN)
IndependentRMSE = RMSE(as.numeric(simdat[myindex,]$Independent50),myN)

#Average width of interval
cMLCRwidth = mean(as.numeric(simdat[myindex,]$cMLCR97.5)-as.numeric(simdat[myindex,]$cMLCR2.5))/myN
HSPBLRCwidth = mean(as.numeric(simdat[myindex,]$HSPBLRCR97.5)-as.numeric(simdat[myindex,]$HSPBLRCR2.5))/myN
SPBLRCwidth = mean(as.numeric(simdat[myindex,]$SPBLRCR97.5)-as.numeric(simdat[myindex,]$SPBLRCR2.5))/myN
normBLRCwidth = mean(as.numeric(simdat[myindex,]$normBLRCR97.5)-as.numeric(simdat[myindex,]$normBLRCR2.5))/myN
LCMCRwidth = mean(as.numeric(simdat[myindex,]$LCMCR97.5)-as.numeric(simdat[myindex,]$LCMCR2.5))/myN
loglinwidth = mean(as.numeric(simdat[myindex,]$loglin97.5)-as.numeric(simdat[myindex,]$loglin2.5))/myN
Independentwidth = mean(as.numeric(simdat[myindex,]$Independent97.5)-as.numeric(simdat[myindex,]$Independent2.5))/myN

#Check Percentage in Interval
cMLRCCI = mean(as.numeric(simdat[myindex,]$cMLCR2.5)<myN&as.numeric(simdat[myindex,]$cMLCR97.5)>myN)*100
HSPBLRCCI = mean(as.numeric(simdat[myindex,]$HSPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$HSPBLRCR97.5)>myN)*100
SPBLRCCI = mean(as.numeric(simdat[myindex,]$SPBLRCR2.5)<myN&as.numeric(simdat[myindex,]$SPBLRCR97.5)>myN)*100
normBLRCCI = mean(as.numeric(simdat[myindex,]$normBLRCR2.5)<myN&as.numeric(simdat[myindex,]$normBLRCR97.5)>myN)*100
LCMCRCI = mean(as.numeric(simdat[myindex,]$LCMCR2.5)<myN&as.numeric(simdat[myindex,]$LCMCR97.5)>myN)*100
loglinCI = mean(as.numeric(simdat[myindex,]$loglin2.5)<myN&as.numeric(simdat[myindex,]$loglin97.5)>myN)*100
IndependentCI = mean(as.numeric(simdat[myindex,]$Independent2.5)<myN&as.numeric(simdat[myindex,]$Independent97.5)>myN)*100
```
\hline
10000    & BLRCR($K=1$, $H_\omega=1$)  & `r op(normBLRCRNhat,3)`   & `r op(normBLRCRMSE,1)`   & `r op(normBLRCwidth,3)`   & `r op(normBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=1$)    & `r op(SPBLRCRNhat,3)`     & `r op(SPBLRCRMSE,1)`     & `r op(SPBLRCwidth,3)`     & `r op(SPBLRCCI,1)` \\ 
               & BLRCR($K=20$, $H_\omega=20$)    & `r op(HSPBLRCRNhat,3)`     & `r op(HSPBLRCRMSE,1)`     & `r op(HSPBLRCwidth,3)`     & `r op(HSPBLRCCI,1)` \\  
               & cMLCR       & `r op(cMLCRNhat,3)`       & `r op(cMLCRRMSE,1)`      & `r op(cMLCRwidth,3)`      & `r op(cMLRCCI,1)` \\
               & Log Linear (BIC)  & `r op(loglinNhat,3)`      & `r op(loglinRMSE,1)`     & `r op(loglinwidth,3)`     & `r op(loglinCI,1)` \\ 
               & LCMCR       & `r op(LCMCRNhat,3)`       & `r op(LCMCRRMSE,1)`      & `r op(LCMCRwidth,3)`      & `r op(LCMCRCI,1)` \\ 
               & Independent & `r op(IndependentNhat,3)` & `r op(IndependentRMSE,1)`& `r op(Independentwidth,3)`& `r op(IndependentCI,1)` \\ 
\hline
\end{tabular}
\caption{Results of 100 capture-recapture simulations per varying population sizes using "Moderate" list dependency and two standard normal covariates. }
\label{table:diffsizes}
\end{table}


```{r plotNvalues, fig.align='center',fig.width=8,fig.height=6,fig.margin=TRUE,fig.cap="\\label{fig:normalx} Correlation Plot of the 100 estimates for N using BLRCR and cMLCR when simulating from two independent standard normal distributions with moderate dependency between lists and a true population size of N=2000."}
#Set N and BETA
myN=2000
myBeta="moderate"
myindex <- simdat$N==myN & simdat$BETA==myBeta & simdat$covariates=="twonormalcovs"

#Get estimates
BLRCRN = as.numeric(simdat[myindex,]$normBLRCR50)
HSPBLRCRN = as.numeric(simdat[myindex,]$HSPBLRCR50)
SPBLRCRN = as.numeric(simdat[myindex,]$SPBLRCR50)
cMLCRN = as.numeric(simdat[myindex,]$cMLCR)


Nestimates=data.frame("B1"=BLRCRN,
                      "B2"=SPBLRCRN,
                      "B3"=HSPBLRCRN,
                      "cMLCR"=cMLCRN)

lowerfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_point()+
    geom_abline(intercept=0,slope=1)
    #scale_x_continuous(limits = c(1750,2250))+
    #scale_y_continuous(limits = c(1750,2250))
}
ggpairs(Nestimates,
        columnLabels = c("BLRCR(K=1,Hw=1)",
                         "BLRCR(K=20,Hw=1)",
                         "BLRCR(K=20,Hw=20)",
                         "cMLCR"),
        rowLabels =    c("BLRCR(K=1,Hw=1)",
                         "BLRCR(K=20,Hw=1)",
                         "BLRCR(K=20,Hw=20)",
                         "cMLCR"),
        lower=list(continuous=wrap(lowerfun))) + theme_bw()
```



Overall, the BLRCR model is shown to be consistent.  It also tends to outperform or equally perform the other methods in terms of MSE, CI width, and CI$\%$.